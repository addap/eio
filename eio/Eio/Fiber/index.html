<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fiber (eio.Eio.Fiber)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">eio</a> &#x00BB; <a href="../index.html">Eio</a> &#x00BB; Fiber</nav><header class="odoc-preamble"><h1>Module <code><span>Eio.Fiber</span></code></h1><p>A fiber is a light-weight thread.</p><p>Within a domain, only one fiber can be running at a time. A fiber runs until it performs an IO operation (directly or indirectly). At that point, it may be suspended and the next fiber on the run queue runs.</p></header><nav class="odoc-toc"><ul><li><a href="#concurrent-list-operations">Concurrent list operations</a></li><li><a href="#fiber-local-variables">Fiber-local variables</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec value" id="val-both" class="anchored"><a href="#val-both" class="anchor"></a><code><span><span class="keyword">val</span> both : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>both f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and if either raises an exception, the other is cancelled. <code>both</code> waits for both functions to finish even if one raises (it will then re-raise the original exception).</p><p><code>f</code> runs immediately, without switching to any other thread. <code>g</code> is inserted at the head of the run-queue, so it runs next even if other threads are already enqueued. You can get other scheduling orders by adding calls to <a href="#val-yield"><code>yield</code></a> in various places. e.g. to append both fibers to the end of the run-queue, yield immediately before calling <code>both</code>.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pair" class="anchored"><a href="#val-pair" class="anchor"></a><code><span><span class="keyword">val</span> pair : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> * <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>pair f g</code> is like <code>both</code>, but returns the two results.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-all" class="anchored"><a href="#val-all" class="anchor"></a><code><span><span class="keyword">val</span> all : <span><span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>all fs</code> is like <code>both</code>, but for any number of fibers. <code>all []</code> returns immediately.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-first" class="anchored"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>first f g</code> runs <code>f ()</code> and <code>g ()</code> concurrently.</p><p>They run in a new cancellation sub-context, and when one finishes the other is cancelled. If one raises, the other is cancelled and the exception is reported.</p><p>As with <code>both</code>, <code>f</code> runs immediately and <code>g</code> is scheduled next, ahead of any other queued work.</p><p>If both fibers fail, <a href="../Exn/index.html#val-combine"><code>Exn.combine</code></a> is used to combine the exceptions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-any" class="anchored"><a href="#val-any" class="anchor"></a><code><span><span class="keyword">val</span> any : <span><span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>any fs</code> is like <code>first</code>, but for any number of fibers.</p><p><code>any []</code> just waits forever (or until cancelled).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-await_cancel" class="anchored"><a href="#val-await_cancel" class="anchor"></a><code><span><span class="keyword">val</span> await_cancel : <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>await_cancel ()</code> waits until cancelled.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Cancel.Cancelled</span> </li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fork" class="anchored"><a href="#val-fork" class="anchor"></a><code><span><span class="keyword">val</span> fork : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fork ~sw fn</code> runs <code>fn ()</code> in a new fiber, but does not wait for it to complete.</p><p>The new fiber is attached to <code>sw</code> (which can't finish until the fiber ends).</p><p>The new fiber inherits <code>sw</code>'s cancellation context. If the fiber raises an exception, <code>Switch.fail sw</code> is called. If <code>sw</code> is already off then <code>fn</code> fails immediately, but the calling thread continues.</p><p><code>fn</code> runs immediately, without switching to any other fiber first. The calling fiber is placed at the head of the run queue, ahead of any previous items.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_sub" class="anchored"><a href="#val-fork_sub" class="anchor"></a><code><span><span class="keyword">val</span> fork_sub : 
  <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>on_error:<span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>fork_sub ~sw ~on_error fn</code> is like <code>fork</code>, but it creates a new sub-switch for the fiber.</p><p>This means that you can cancel the child switch without cancelling the parent. This is a convenience function for running <a href="../Switch/index.html#val-run"><code>Switch.run</code></a> inside a <a href="#val-fork"><code>fork</code></a>.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">on_error</span> <p>This is called if the fiber raises an exception. If it raises in turn, the parent switch is failed. It is not called if the parent <code>sw</code> itself is cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_promise" class="anchored"><a href="#val-fork_promise" class="anchor"></a><code><span><span class="keyword">val</span> fork_promise : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="../Promise/index.html#type-or_exn">Promise.or_exn</a></span></span></code></div><div class="spec-doc"><p><code>fork_promise ~sw fn</code> schedules <code>fn ()</code> to run in a new fiber and returns a promise for its result.</p><p>This is just a convenience wrapper around <a href="#val-fork"><code>fork</code></a>. If <code>fn</code> raises an exception then the promise is resolved to the error, but <code>sw</code> is not failed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fork_daemon" class="anchored"><a href="#val-fork_daemon" class="anchor"></a><code><span><span class="keyword">val</span> fork_daemon : <span>sw:<a href="../Switch/index.html#type-t">Switch.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span>[ `Stop_daemon ]</span> )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>fork_daemon</code> is like <a href="#val-fork"><code>fork</code></a> except that instead of waiting for the fiber to finish, the switch will cancel it once all non-daemon fibers are done.</p><p>The switch will still wait for the daemon fiber to finish cancelling.</p><p>The return type of <code>[`Stop_daemon]</code> instead of <code>unit</code> is just to catch mistakes, as daemons normally aren't expected to return.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-check" class="anchored"><a href="#val-check" class="anchor"></a><code><span><span class="keyword">val</span> check : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>check ()</code> checks that the fiber's context hasn't been cancelled. Many operations automatically check this before starting.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Cancel.Cancelled</span> <p>if the fiber's context has been cancelled.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-yield" class="anchored"><a href="#val-yield" class="anchor"></a><code><span><span class="keyword">val</span> yield : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>yield ()</code> asks the scheduler to switch to the next runnable task. The current task remains runnable, but goes to the back of the queue. Automatically calls <a href="#val-check"><code>check</code></a> just before resuming.</p></div></div><h3 id="concurrent-list-operations"><a href="#concurrent-list-operations" class="anchor"></a>Concurrent list operations</h3><div class="odoc-spec"><div class="spec value" id="val-filter" class="anchored"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span>?max_fibers:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p><code>filter f x</code> is like <code>List.filter f x</code> except that the invocations of <code>f</code> are run concurrently in separate fibers.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fibers</span> <p>Maximum number of fibers to run concurrently</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-map" class="anchored"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span>?max_fibers:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>map f x</code> is like <code>List.map f x</code> except that the invocations of <code>f</code> are run concurrently in separate fibers.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fibers</span> <p>Maximum number of fibers to run concurrently</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-filter_map" class="anchored"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span>?max_fibers:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> list</span></span></code></div><div class="spec-doc"><p><code>filter_map f x</code> is like <code>List.filter_map f x</code> except that the invocations of <code>f</code> are run concurrently in separate fibers.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fibers</span> <p>Maximum number of fibers to run concurrently</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-iter" class="anchored"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span>?max_fibers:int <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f x</code> is like <code>List.iter f x</code> except that the invocations of <code>f</code> are run concurrently in separate fibers.</p><ul class="at-tags"><li class="parameter"><span class="at-tag">parameter</span> <span class="value">max_fibers</span> <p>Maximum number of fibers to run concurrently</p></li></ul></div></div><h3 id="fiber-local-variables"><a href="#fiber-local-variables" class="anchor"></a>Fiber-local variables</h3><p>Each fiber maintains a map of additional variables associated with it, which can be used to store fiber-related state or context. This map is propagated to any forked fibers.</p><p>While fiber-local variables can be useful, they can also make code much harder to reason about, as they effectively act as another form of global state. When possible, prefer passing arguments around explicitly.</p><p>Fiber-local variables are particularly useful for attaching extra information for debugging, such as a request ID that the log system can include in all logged messages.</p><div class="odoc-spec"><div class="spec type" id="type-key" class="anchored"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a key</span></span></code></div><div class="spec-doc"><p><code>'a key</code> is a fiber-local variable of type <code>'a</code>.</p><p>Since the key is required to get or set a variable, a library can keep its key private to control how the variable can be accessed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-create_key" class="anchored"><a href="#val-create_key" class="anchor"></a><code><span><span class="keyword">val</span> create_key : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-key">key</a></span></span></code></div><div class="spec-doc"><p><code>create_key ()</code> creates a new fiber-local variable.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get" class="anchored"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>get key</code> reads <code>key</code> from the map of fiber local variables, returning its value or <code>None</code> if it has not been bound.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-with_binding" class="anchored"><a href="#val-with_binding" class="anchor"></a><code><span><span class="keyword">val</span> with_binding : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_binding key value fn</code> runs <code>fn</code> with <code>key</code> bound to the provided <code>value</code>.</p><p>Whilst this binding only exists for the duration of this function <i>on this fiber</i>, it will be propagated to any forked fibers. If <code>fn</code> creates fibers using an external switch, the bound value may be continue to be used after this function returns.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-without_binding" class="anchored"><a href="#val-without_binding" class="anchor"></a><code><span><span class="keyword">val</span> without_binding : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>unit <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>with_binding key value fn</code> runs <code>fn</code> with any binding for <code>key</code> removed.</p></div></div></div></body></html>