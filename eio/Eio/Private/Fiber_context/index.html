<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fiber_context (eio.Eio.Private.Fiber_context)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">eio</a> &#x00BB; <a href="../../index.html">Eio</a> &#x00BB; <a href="../index.html">Private</a> &#x00BB; Fiber_context</nav><header class="odoc-preamble"><h1>Module <code><span>Private.Fiber_context</span></code></h1><p>Every fiber has an associated context.</p></header><nav class="odoc-toc"><ul><li><a href="#cancellation">Cancellation</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-make_root" class="anchored"><a href="#val-make_root" class="anchor"></a><code><span><span class="keyword">val</span> make_root : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Make a new root context for a new domain.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-destroy" class="anchored"><a href="#val-destroy" class="anchor"></a><code><span><span class="keyword">val</span> destroy : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>destroy t</code> removes <code>t</code> from its cancellation context.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tid" class="anchored"><a href="#val-tid" class="anchor"></a><code><span><span class="keyword">val</span> tid : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Ctf/index.html#type-id">Ctf.id</a></span></code></div></div><h3 id="cancellation"><a href="#cancellation" class="anchor"></a>Cancellation</h3><p>The <a href="../../Cancel/index.html"><code>Cancel</code></a> module describes the user's view of cancellation.</p><p>Internally, when the user calls a primitive operation that needs to block the fiber, the <code>Suspend callback</code> effect is performed. This suspends the fiber and calls <code>callback</code> from the scheduler's context, passing it the suspended fiber's context. If the operation can be cancelled, the callback should use <a href="#val-set_cancel_fn"><code>set_cancel_fn</code></a> to register a cancellation function.</p><p>There are two possible outcomes for the operation: it may complete normally, or it may be cancelled. If it is cancelled then the registered cancellation function is called. This function will always be called from the fiber's own domain, but care must be taken if the operation is being completed by another domain at the same time.</p><p>Consider the case of <a href="../../Stream/index.html#val-take"><code>Stream.take</code></a>, which can be fulfilled by a <a href="../../Stream/index.html#val-add"><code>Stream.add</code></a> from another domain. We want to ensure that either the item is removed from the stream and returned to the waiting fiber, or that the operation is cancelled and the item is not removed from the stream.</p><p>Therefore, cancelling and completing both attempt to clear the cancel function atomically, so that only one can succeed. The case where <code>Stream.take</code> succeeds before cancellation:</p><ol><li>A fiber calls <code>Suspend</code> and is suspended. The callback sets a cancel function and registers a waiter on the stream.</li><li>When another domain has an item, it removes the cancel function (making the <code>take</code> uncancellable) and begins resuming the fiber with the new item.</li><li>If the taking fiber is cancelled after this, the cancellation will be ignored and the operation will complete successfully. Future operations will fail immediately, however.</li></ol><p>The case of cancellation winning the race:</p><ol><li>A fiber calls <code>Suspend</code> and is suspended. The callback sets a cancel function and registers a waiter on the stream.</li><li>The taking fiber is cancelled. Its cancellation function is called, which starts removing the waiter.</li><li>If another domain tries to provide an item to the waiter as this is happening, it will try to clear the cancel function and fail. The item will be given to the next waiter instead.</li></ol><p>Note that there is a mutex around the list of waiters, so the taking domain can't finish removing the waiter and start another operation while the adding domain is trying to resume it. In future, we may want to make this lock-free by using a fresh atomic to hold the cancel function for each operation.</p><p>Note: A fiber will only have a cancel function set while it is suspended.</p><div class="odoc-spec"><div class="spec value" id="val-cancellation_context" class="anchored"><a href="#val-cancellation_context" class="anchor"></a><code><span><span class="keyword">val</span> cancellation_context : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Cancel/index.html#type-t">Cancel.t</a></span></code></div><div class="spec-doc"><p><code>cancellation_context t</code> is <code>t</code>'s current cancellation context.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-set_cancel_fn" class="anchored"><a href="#val-set_cancel_fn" class="anchor"></a><code><span><span class="keyword">val</span> set_cancel_fn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span>exn <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set_cancel_fn t fn</code> sets <code>fn</code> as the fiber's cancel function.</p><p>If the cancellation context is cancelled, the function is removed and called. When the operation completes, you must call <a href="#val-clear_cancel_fn"><code>clear_cancel_fn</code></a> to remove it.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-clear_cancel_fn" class="anchored"><a href="#val-clear_cancel_fn" class="anchor"></a><code><span><span class="keyword">val</span> clear_cancel_fn : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>clear_cancel_fn t</code> removes the function previously set with <a href="#val-set_cancel_fn"><code>set_cancel_fn</code></a>, if any.</p><p>Returns <code>true</code> if this call removed the function, or <code>false</code> if there wasn't one. This operation is atomic and thread-safe. An operation that completes in another domain must use this to indicate that the operation is finished (can no longer be cancelled) before enqueuing the result. If it returns <code>false</code>, the operation was cancelled first and the canceller has called (or is calling) the function. If it returns <code>true</code>, the caller is responsible for any resources owned by the function, such as the continuation.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_error" class="anchored"><a href="#val-get_error" class="anchor"></a><code><span><span class="keyword">val</span> get_error : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>exn option</span></span></code></div><div class="spec-doc"><p><code>get_error t</code> is <code>Cancel.get_error (cancellation_context t)</code></p></div></div></div></body></html>