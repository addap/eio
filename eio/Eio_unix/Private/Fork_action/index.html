<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Fork_action (eio.Eio_unix.Private.Fork_action)</title><link rel="stylesheet" href="../../../../_odoc_support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../_odoc_support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">eio</a> &#x00BB; <a href="../../index.html">Eio_unix</a> &#x00BB; <a href="../index.html">Private</a> &#x00BB; Fork_action</nav><header class="odoc-preamble"><h1>Module <code><span>Private.Fork_action</span></code></h1><p>Actions to perform after forking a child process.</p><p>To spawn a child executable on Unix, the parent forks a copy of itself, then has the child copy set up the environment for the new program and execute it.</p><p>However, we cannot run any OCaml code in the forked child process. This is because `fork` only duplicates its own domain. To the child, it appears that all other domains have stopped responding and if it tries to e.g. perform a GC then the child process will hang.</p><p>Therefore, the fork call and all child actions need to be written in C. This module provides some support code for doing that. Individual backends will wrap these actions with higher-level APIs and can also add their own platform-specific actions</p></header><nav class="odoc-toc"><ul><li><a href="#actions">Actions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-fork_fn"><a href="#type-fork_fn" class="anchor"></a><code><span><span class="keyword">type</span> fork_fn</span></code></div><div class="spec-doc"><p>A C function, as defined in &quot;include/fork_action.h&quot;.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-c_action"><a href="#type-c_action" class="anchor"></a><code><span><span class="keyword">type</span> c_action</span><span> = <span class="xref-unresolved">Stdlib</span>.Obj.t</span></code></div><div class="spec-doc"><p>An action to be performed in a child process after forking. This must be a tuple whose first field is a <code>fork_fn</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span><span>{</span></code><ol><li id="type-t.run" class="def record field anchored"><a href="#type-t.run" class="anchor"></a><code><span>run : 'a. <span><span>(<span><a href="#type-c_action">c_action</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>An action that calls <code>run k</code> in the parent process to create the C action. <code>run</code> passes the action to <code>k</code>, which forks the child and runs it. When <code>k</code> returns, <code>run</code> can free any resources used.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_actions"><a href="#val-with_actions" class="anchor"></a><code><span><span class="keyword">val</span> with_actions : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><a href="#type-c_action">c_action</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div></div><h3 id="actions"><a href="#actions" class="anchor"></a>Actions</h3><div class="odoc-spec"><div class="spec value anchored" id="val-execve"><a href="#val-execve" class="anchor"></a><code><span><span class="keyword">val</span> execve : <span>string <span class="arrow">&#45;&gt;</span></span> <span>argv:<span>string array</span> <span class="arrow">&#45;&gt;</span></span> <span>env:<span>string array</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>See <code>execve(2)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-chdir"><a href="#val-chdir" class="anchor"></a><code><span><span class="keyword">val</span> chdir : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>chdir path</code> changes directory to <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fchdir"><a href="#val-fchdir" class="anchor"></a><code><span><span class="keyword">val</span> fchdir : <span><span class="xref-unresolved">Eio_unix__.Rcfd.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>fchdir fd</code> changes directory to <code>fd</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-blocking"><a href="#type-blocking" class="anchor"></a><code><span><span class="keyword">type</span> blocking</span><span> = </span><span>[ </span></code><ol><li id="type-blocking.Blocking" class="def constructor anchored"><a href="#type-blocking.Blocking" class="anchor"></a><code><span>| </span></code><code><span>`Blocking</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Clear the <code>O_NONBLOCK</code> flag in the child process.</p><span class="comment-delim">*)</span></div></li><li id="type-blocking.Nonblocking" class="def constructor anchored"><a href="#type-blocking.Nonblocking" class="anchor"></a><code><span>| </span></code><code><span>`Nonblocking</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Set the <code>O_NONBLOCK</code> flag in the child process.</p><span class="comment-delim">*)</span></div></li><li id="type-blocking.Preserve_blocking" class="def constructor anchored"><a href="#type-blocking.Preserve_blocking" class="anchor"></a><code><span>| </span></code><code><span>`Preserve_blocking</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Don't change the blocking mode of the FD.</p><span class="comment-delim">*)</span></div></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inherit_fds"><a href="#val-inherit_fds" class="anchor"></a><code><span><span class="keyword">val</span> inherit_fds : <span><span><span>(int * <span class="xref-unresolved">Eio_unix__.Rcfd.t</span> * <span>[&lt; <a href="#type-blocking">blocking</a> ]</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>inherit_fds mapping</code> marks file descriptors as not close-on-exec and renumbers them.</p><p>For each (fd, src, flags) in <code>mapping</code>, we use <code>dup2</code> to duplicate <code>src</code> as <code>fd</code>. If there are cycles in <code>mapping</code>, a temporary FD is used to break the cycle. A mapping from an FD to itself simply clears the close-on-exec flag.</p><p>After this, the new FDs may also be set as blocking or non-blocking, depending on <code>flags</code>.</p></div></div></div></body></html>